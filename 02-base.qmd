---
editor: 
  markdown: 
    wrap: sentence
---

# Quelques notions de base sur R {#sec-basics-r}

Objectif de ce chapitre :

-   Créer des objets et leur attribuer des valeurs.
-   Explorer les différents types d'objets et effectuer des opérations courantes sur ces objets.
-   Obtenir de l'aide en R et présenter certaines ressources pour vous aider à apprendre R.
-   Sauvegarder votre travail.
-   Utiliser et installer des paquets :package: pour étendre les capacités de base de R.

## Considérations importantes

Les captures d'écrans présentées proviennent de RStudio mais tout est très similaire sur VSCode.

Avant de poursuivre, quelques points à garder à l'esprit tout au long de ce chapitre :

-   R est sensible à la casse, c'est-à-dire que `A` n'est pas la même chose que `a` et `anova`, ce n'est pas `Anova`.

-   Tout ce qui suit un `#` est interprété comme un commentaire et ignoré par R.
    Ces *commentaires* doivent être utilisés librement dans votre code, à la fois pour votre propre information et pour aider vos collaborateurs.
    L'écriture de commentaires est un peu un [art][comment] que vous maîtriserez de mieux en mieux avec l'expérience.

-   Dans R, les commandes sont généralement séparées par une nouvelle ligne.
    Vous pouvez également utiliser un point-virgule `;` pour séparer vos commandes, mais nous vous le déconseillons fortement (rend le code très difficilement lisible).

-   Si une invite de continuation `+` apparaît dans la console après l'exécution de votre code, cela signifie que vous n'avez pas terminé votre code correctement.
    Cela se produit souvent lorsque vous oubliez de fermer une parenthèse, ce qui est particulièrement fréquent lors que l'on utilise des parenthèses imbriquées (`(((commande quelconque))`).
    Terminez simplement la commande sur la nouvelle ligne ou appuyez sur la touche "escape" de votre clavier (voir le point ci-dessous) et corrigez la faute de frappe.

-   En général, R est assez tolérant vis-à-vis des espaces supplémentaires insérés dans votre code, en fait l'utilisation d'espaces est activement encouragée.
    Cependant, les espaces ne doivent pas être insérés dans les opérateurs, c'est-à-dire `<-` ne peut pas s'écrire `< -` (notez l'espace).
    Voir le [guide de style][style-google] pour savoir où placer les espaces afin de rendre votre code plus lisible.

-   Si votre console se bloque et ne répond plus après l'exécution d'une commande, vous pouvez souvent vous sortir d'affaire en appuyant sur la touche "escape" (esc) de votre clavier ou en cliquant sur l'icône d'arrêt/stop en haut à droite de votre console.
    Cela mettra fin à la plupart des opérations en cours.

## Première étape dans la console

Dans le @sec-chap1, nous avons appris ce qu'était la [console R](#sec-cons) la création de scripts et de [Projets](#sec-rsprojs).
Nous avons également vu comment écrire votre code R dans un script, puis comment insérer ce code dans la console pour qu'il s'exécute (si vous avez oublié comment faire, revenez à la section sur la console (-@sec-cons) pour vous rafraîchir la mémoire).
Le fait d'écrire votre code dans un script signifie que vous aurez un enregistrement permanent de tout ce que vous avez fait (à condition de sauvegarder votre script) et vous permet également de faire de nombreux commentaires pour vous rappeler ce que vous aviez fait (ou voulu faire) quand vous retournerez si votre code à l'avenir.
Ainsi, pendant que vous travaillez sur ce chapitre, nous vous suggérons de créer un nouveau script (ou un [Projet](#sec-rsprojs) Rstudio) pour écrire votre code au fur et à mesure.

Comme nous l'avons vu au @sec-chap1, nous pouvons utiliser R de la même manière qu'une calculatrice.
Nous pouvons saisir une expression arithmétique dans notre script, puis l'envoyer dans la console et recevoir un résultat.
Par exemple, si nous tapons l'expression `1 + 1` et que l'on exécute cette ligne de code dans la console, on obtient la réponse `2` (:smiley: !)

```{r}
#| echo: true
#| eval: true
1 + 1
```

Le `[1]` devant le résultat indique que l'observation au début de la ligne est la première.
Cela n'est pas très utile dans cet exemple, mais peut l'être lors de l'impression de résultats sur plusieurs lignes (nous en verrons un exemple ci-dessous).
Les autres opérateurs arithmétiques évidents sont `-`, `*`, `/` pour la soustraction, la multiplication et la division respectivement.
Pour la multiplication de la matrice, l'opérateur est `%*%`.

R suit la convention mathématique habituelle de l'[ordre des opérations][op-prec].
Par exemple, l'expression `2 + 3 * 4` est interprétée comme ayant la valeur `2 + (3 * 4) = 14` et non `(2 + 3) * 4 = 20`.
Il existe un grand nombre de fonctions mathématiques dans R, dont les plus utiles sont les suivantes : `log()`, `log10()`, `exp()`, `sqrt()`.

```{r}
#| echo: true
#| eval: true
log(1) # logarithme en base e
log10(1) # logarithme en base 10
exp(1) # antilog naturel, fonction exponentielle
sqrt(4) # racine carrée
4^2 # 4 puissance 2
pi # pas une fonction mais utile
```

Il est important de comprendre que lorsque vous exécutez un code comme nous l'avons fait ci-dessus, le résultat du code (ou **valeur**) n'est affiché que dans la console.
Bien que cela puisse parfois être utile, il est généralement beaucoup plus pratique de stocker la ou les valeurs dans un **objet**.

## Objets en R

Au cœur de presque tout ce que vous ferez (ou ferez probablement) en R se trouve le concept selon lequel tout en R est un [objet][chambers].
Ces objets peuvent être pratiquement n'importe quoi, d'un simple nombre ou d'une chaîne de caractères (comme un mot) à des structures très complexes comme la sortie d'un graphique, un résumé de votre analyse statistique ou un ensemble de commandes R effectuant une tâche spécifique.
Pour comprendre R, il est essentiel de savoir comment créer des objets et leur attribuer des valeurs.

### Création d'objets {#sec-r-objs}

Pour créer un objet, il suffit de lui donner un nom.
Nous pouvons ensuite attribuer une valeur à cet objet à l'aide d'un *opérateur d'affectation* `<-` (parfois appelé *opérateur d'obtention*).
L'opérateur d'affectation est un symbole composite composé d'un symbole "moins que" `<` et d'un trait d'union `-`

> raccourci clavier : "option" + "-" sur Mac ; "alt" + "-" sur Windows.

```{r}
#| echo: true
#| eval: true
mon_obj <- 32
```

Dans le code ci-dessus, nous avons créé un objet appelé `mon_obj` et lui avons attribué la valeur numérique `32` à l'aide de l'opérateur d'affectation (dans notre tête, nous lisons toujours cela comme '*mon_obj est 32*').
Vous pouvez également utiliser `=` à la place de `<-` pour assigner des valeurs, mais c'est une mauvaise pratique car cela peut entraîner des confusions plus tard quand vous programmerez en `R` (voir @sec-prog-r) donc nous vous déconseillons d'utiliser cette notation.

Pour afficher la valeur de l'objet, il suffit de taper son nom.

```{r}
#| echo: true
#| eval: true
mon_obj
```

Maintenant que nous avons créé cet objet, R le connaît et en gardera la trace pendant la session R en cours.
Tous les objets que vous créez sont stockés dans l'espace de travail actuel et vous pouvez visualiser tous les objets de votre espace de travail dans RStudio en cliquant sur l'onglet "Environnement" dans le volet supérieur droit.

```{r}
#| label: fig-rstudio_env
#| fig-cap: Onglet Environnement RStudio
#| echo: false
#| out-width: 75%
#| fig-align: center
knitr::include_graphics(path = "images/basic/rs_env-fr.png")
```

Si vous cliquez sur la flèche vers le bas de l'icône "List" (Liste) dans le même volet et que vous passez à l'affichage "Grid" (Grille), RStudio vous présentera un résumé des objets, y compris le type ("numeric" (numérique) - c'est un nombre), la longueur (une seule valeur dans cet objet), sa taille "physique" et sa valeur (32 dans ce cas).
Dans VSCode, allez sur le panneau d'extension R et vous obtiendrez les mêmes informations.

```{r}
#| label: fig-rstudio_env2
#| fig-cap: Onglet Environnement RStudio au format grille
#| echo: false
#| out-width: 75%
#| fig-align: center
knitr::include_graphics(path = "images/basic/rs_env2-fr.png")
```

Il existe de nombreux types de valeurs que vous pouvez attribuer à un objet.
Par exemple

```{r}
#| echo: true
#| eval: true
mon_obj2 <- "R c'est trop bien"
```

Nous avons créé un objet appelé `mon_obj2` et lui avons attribué la valeur `R c'est trop bien` qui est une chaîne de caractères.
Remarquez que nous avons mis la chaîne de caractères entre guillemets.
Si vous oubliez d'utiliser les guillemets, vous recevrez un message d'erreur.

Notre espace de travail contient maintenant les deux objets que nous avons créés jusqu'à présent avec `mon_obj2` de type "character" (caractère).

```{r}
#| label: fig-rstudio_env3
#| fig-cap: Onglet Environnement RStudio avec mon_obj2 de type caractère
#| echo: false
#| out-width: 75%
#| fig-align: center
knitr::include_graphics(path = "images/basic/rs_env3-fr.png")
```

Pour modifier la valeur d'un objet existant, il suffit de lui réattribuer une nouvelle valeur.
Par exemple, pour modifier la valeur de `mon_obj2` de `"R c'est trop bien"` au nombre `1024`

```{r}
#| echo: true
#| eval: true
mon_obj2 <- 1024
```

Remarquez que le type est devenu numérique et que la valeur est passée à 1024 dans l'environnement.

```{r}
#| label: fig-rstudio_env4
#| fig-cap: Onglet Environnement RStudio avec mon_obj2 mis-à-jours en numérique
#| echo: false
#| out-width: 75%
#| fig-align: center
knitr::include_graphics(path = "images/basic/rs_env4-fr.png")
```

Une fois que nous avons créé plusieurs objets, nous pouvons faire des choses avec.
Par exemple, le code suivant crée un nouvel objet `mon_obj3` et lui assigne la valeur de `mon_obj` ajouté à `mon_obj2` soit 1056 (32 + 1024 = 1056).

```{r}
#| echo: true
#| eval: true
mon_obj3 <- mon_obj + mon_obj2
mon_obj3
```

Remarquez que pour afficher la valeur de `mon_obj3` nous devons également écrire le nom de l'objet.
Le code ci-dessus fonctionne parce que les valeurs de `mon_obj` et `mon_obj2` sont numériques (donc des nombres).
Si vous essayez de faire ça avec des objets dont les valeurs sont des caractères (**classe character**), vous recevrez une erreur

```{r}
#| echo: true
#| eval: false
char_obj <- "hello"
char_obj2 <- "world!"
char_obj3 <- char_obj + char_obj2
# Error in char_obj+char_obj2:non-numeric argument to binary operator
```

Le message d'erreur vous indique que l'un ou les deux objets `char_obj` et `char_obj2` n'est pas un nombre et ne peut donc pas être additionné.

Lorsque vous commencez à apprendre R, la gestion des erreurs et des avertissements peut être frustrante car ils sont souvent difficiles à comprendre (qu'est-ce qu'un [*argument*][r_arg] ? qu'est-ce qu'un [*opérateur binaire*][bin_op] ?).
Une façon de trouver plus d'informations sur une erreur particulière est de rechercher une version généralisée du message d'erreur.
Pour l'erreur ci-dessus, essayez de rechercher [*'non-numeric argument to binary operator error + r'*][non_num_err] ou même [*'common r error messages'*][com_err].

Un autre message d'erreur que vous obtiendrez assez souvent lorsque vous commencerez à utiliser R est `Error : object 'XXX' not found` (erreur : objet 'XXX' non trouvé).
A titre d'exemple, regardez le code ci-dessous

``` r
mon_obj <- 48
mon_obj4 <- mon_obj + no_obj
# Error: object 'no_obj' not found
```

R renvoie un message d'erreur parce que nous n'avons pas encore créé (défini) l'objet `no_obj`.
Un autre indice qu'il y a un problème avec ce code est que, si vous vérifiez votre environnement, vous verrez que l'objet `mon_obj4` n'a pas été créé.

### Nommer les objets

Nommer vos objets est l'une des choses les plus difficiles que vous ferez dans R.
Idéalement, les noms de vos objets devraient être courts et informatifs, ce qui n'est pas toujours facile.
Si vous devez créer des objets avec plusieurs mots dans leur nom, utilisez un trait de soulignement `_` ou un point `.` entre les mots ou mettez les différents mots en majuscules.
Nous préférons le format souligné `_` et n'incluons jamais de majuscules dans les noms (appelé [*snake_case*][snake]).

``` r
résumé_sortie <- "mon analyse" # recommandé #
résumé.sortie <- "mon analyse"
résuméSortie <- "mon analyse"
```

Il y a également quelques limitations lorsqu'il s'agit de donner des noms aux objets.
Un nom d'objet ne peut pas commencer par un chiffre ou un point suivi d'un chiffre (ex. `2ma_variable` ou `.2ma_variable`).
Vous devez également éviter d'utiliser des caractères non alphanumériques dans vos noms d'objets (i.e. &, \^, /, ! etc).
De plus, assurez-vous de ne pas nommer vos objets avec des mots réservés (i.e. `TRUE`, `NA`) et ce n'est jamais une bonne idée de donner à votre objet le même nom qu'une fonction intégrée.
Une fonction qui revient plus souvent qu'on ne peut s'en souvenir est :

``` r
data <- read.table("monfichierdedonées", header = TRUE)
```

Oui, `data()` est une fonction de R qui permet de charger ou de lister les ensembles de données disponibles dans les paquets.

## Utilisation de fonctions dans R {#sec-funcs}

Jusqu'à présent, nous avons créé des objets simples en assignant directement une valeur unique à un objet.
Il est très probable que vous souhaitiez bientôt créer des objets plus compliqués au fur et à mesure que vous aurez de l'expérience sur R et que la complexité de vos tâches augmente.
Heureusement, R dispose d'une multitude de fonctions pour vous aider à le faire.
Vous pouvez considérer une fonction comme *un objet qui contient une série d'instructions pour effectuer une tâche spécifique*.
L'installation de base de R est livrée avec de nombreuses fonctions déjà définies ou vous pouvez augmenter la puissance de R en installant l'un des 10 000 [paquets](@sec-packages) actuellement disponibles.
Une fois que vous aurez acquis un peu plus d'expérience dans l'utilisation de R, vous voudrez peut-être définir vos propres fonctions pour effectuer des tâches spécifiques à vos objectifs (plus d'informations à ce sujet dans @sec-prog-r).

La première fonction que nous allons découvrir est la fonction `c()`.
La fonction `c()` est l'abréviation de concaténer et nous l'utilisons pour joindre une série de valeurs et les stocker dans une structure de données appelée [**vecteur**][vector] (plus d'informations sur les vecteurs dans @sec-data-r).

```{r}
#| echo: true
#| eval: true
mon_vec <- c(2, 3, 1, 6, 4, 3, 3, 7)
```

Dans le code ci-dessus, nous avons créé un objet appelé `mon_vec` et lui avons assigné une valeur en utilisant la fonction `c()`.
Il y a quelques points très importants à noter ici.
Premièrement, lorsque vous utilisez une fonction dans R, le nom de la fonction est **toujours** suivi d'une paire de parenthèses rondes `()`, même s'il n'y a rien entre les parenthèses.
Deuxièmement, les arguments d'une fonction sont placés à l'intérieur des parenthèses rondes `()` et sont séparés par des virgules `,`.
Vous pouvez considérer un argument comme un moyen de personnaliser l'utilisation ou le comportement d'une fonction.
Dans l'exemple ci-dessus, les arguments sont les nombres que nous voulons concaténer.
Enfin, l'une des choses les plus délicates lorsque vous commencez à utiliser R est de savoir quelle fonction utiliser pour une tâche particulière et comment l'utiliser.
Heureusement, chaque fonction est toujours associée à un document d'aide qui explique comment utiliser la fonction (plus d'informations à ce sujet plus tard @sec-help) et une recherche rapide sur le web peut également vous aider.

Pour examiner la valeur de notre nouvel objet, nous pouvons simplement taper le nom de l'objet comme nous l'avons fait précédemment

```{r}
#| echo: true
#| eval: true
mon_vec
```

Maintenant que nous avons créé un vecteur, nous pouvons utiliser d'autres fonctions pour faire des choses utiles avec cet objet.
Par exemple, nous pouvons calculer la moyenne, la variance, l'écart-type et le nombre d'éléments de notre vecteur en utilisant les fonctions `mean()`, `var()`, `sd()` et `length()`.

```{r}
#| echo: true
#| eval: true
mean(mon_vec) # renvoie la moyenne de mon_vec
var(mon_vec) # renvoie la variance de mon_vec
sd(mon_vec) # renvoie l'écart-type de mon_vec
length(mon_vec) # renvoie le nombre d'éléments dnas mon_vec
```

Si nous voulons utiliser l'une de ces valeurs plus tard dans notre analyse, il nous suffit d'affecter la valeur obtenue à un autre objet.

```{r}
#| echo: true
#| eval: true
moyenne_vec <- mean(mon_vec) # renvoie la moyenne de mon_vec
moyenne_vec
```

Il peut parfois être utile de créer un vecteur contenant une séquence régulière de valeurs par pas de un.
Dans ce cas, nous pouvons utiliser un raccourci en utilisant le symbole `:`.

```{r}
#| echo: true
#| eval: true
ma_seq <- 1:10 # créer une séquence régulière
ma_seq
ma_seq2 <- 10:1 # en ordre décroissant
ma_seq2
```

D'autres fonctions utiles pour générer des vecteurs de séquences sont `seq()` et `rep()`.
Par exemple, pour générer une séquence de 1 à 5 par pas de 0,5 :

```{r}
#| echo: true
#| eval: true
ma_seq2 <- seq(from = 1, to = 5, by = 0.5)
ma_seq2
```

Ici, nous avons utilisé les arguments `from =` et `to =` pour définir les limites de la séquence et l'argument `by =` pour spécifier l'incrément (les pas) de la séquence.
Jouez avec d'autres valeurs pour ces arguments afin de voir leur effet.

L'argument `rep()` vous permet de répliquer (répéter) des valeurs un certain nombre de fois.
Pour répéter la valeur '2', 10 fois :

```{r}
#| echo: true
#| eval: true
ma_seq3 <- rep(2, times = 10) # répète '2', 10 fois
ma_seq3
```

Vous pouvez également répéter des valeurs non numériques :

```{r}
#| echo: true
#| eval: true
ma_seq4 <- rep("abc", times = 3) # répète ‘abc' 3 fois
ma_seq4
```

ou chaque élément d'une série :

```{r}
#| echo: true
#| eval: true
ma_seq5 <- rep(1:5, times = 3) # répète la série de '1' à '5', 3 fois
ma_seq5
```

ou des éléments d'une série :

```{r}
#| echo: true
#| eval: true
ma_seq6 <- rep(1:5, each = 3) # répète chaque élément de la série 3 fois
ma_seq6
```

On peut aussi répéter une série non séquentielle :

```{r}
#| echo: true
#| eval: true
ma_seq7 <- rep(c(3, 1, 10, 7), each = 3) # répète chaque élément de la série 3 fois
ma_seq7
```

Notez dans le code ci-dessus comment nous avons utilisé la fonction `c()` à l'intérieur de la fonction `rep()`.
L'imbrication de fonctions nous permet de construire des commandes assez complexes à l'intérieur d'une seule ligne de code et est une pratique très courante dans l'utilisation de R.
Cependant, il faut faire attention car trop de fonctions imbriquées peuvent rendre votre code difficile à comprendre pour les autres (et pour vous-même dans le futur !).
Nous pourrions réécrire le code ci-dessus pour séparer explicitement les deux étapes de la génération de notre vecteur.
L'une ou l'autre approche donnera le même résultat, il vous suffit d'utiliser votre propre jugement pour déterminer laquelle est la plus lisible.

```{r}
#| echo: true
#| eval: true
vec_int <- c(3, 1, 10, 7)
ma_seq7 <- rep(vec_int, each = 3) # répète chaque élément de la série, 3 fois
ma_seq7
```

## Travailler avec des vecteurs {#sec-vectors}

Manipuler, résumer et trier des données à l'aide de R est une compétence importante à maîtriser, mais que de nombreuses personnes trouvent un peu déroutante au début.
Nous allons voir ici quelques exemples simples utilisant des vecteurs pour illustrer certains concepts importants, mais nous développerons cela plus en détail dans @sec-data-r où nous verrons des structures de données plus compliquées (et plus utiles).

### Extraction d'éléments

Pour extraire (ou indexer ou souscrire) une ou plusieurs valeurs (plus généralement appelées éléments) d'un vecteur, nous utilisons les crochets `[ ]`.
L'approche générale consiste à nommer l'objet à extraire, puis écrire l'indice de l'élément à extraire dans les crochets.
Cet indice peut être une position ou le résultat d'un test logique.

#### Indice de position {.unnumbered}

Pour extraire des éléments en fonction de leur position, il suffit d'écrire la position à l'intérieur des crochets `[ ]`.
Par exemple, pour extraire la 3e valeur de `mon_vec` :

```{r}
#| echo: true
#| eval: true
mon_vec # rappelons-nous à quoi mon_vec ressemble
mon_vec[3] # extrait la 3e valeur

# si vous voulez stocker cette valeur dans un autre objet
val_3 <- mon_vec[3]
val_3
```

Notez que l'indice de position commence à 1 et non à 0 comme dans d'autres langages de programmation (i.e. Python).

Nous pouvons également extraire plusieurs valeurs en utilisant la fonction `c()` à l'intérieur des crochets.
Ici, nous extrayons le 1^er^, le 5^e^, le 6^e^ et le 8^e^ élément de l'objet `mon_vec` :

```{r}
#| echo: true
#| eval: true
mon_vec[c(1, 5, 6, 8)]
```

Nous pouvons également extraire une plage de valeurs à l'aide de la fonction `:`.
Pour extraire du 3^e^ au 8^e^ élément :

```{r}
#| echo: true
#| eval: true
mon_vec[3:8]
```

#### Indice logique {#sec-logical-index}

Une autre façon très utile d'extraire des données d'un vecteur est d'utiliser une expression logique comme indice.
Par exemple, pour extraire tous les éléments dont la **valeur** est supérieure à 4 dans le vecteur `mon_vec` :

```{r}
#| echo: true
#| eval: true
mon_vec[mon_vec > 4]
```

Ici, l'expression logique est `mon_vec > 4` et R n'extraira que les éléments qui satisfont à cette condition logique.
Comment cela fonctionne-t-il réellement ?
Si nous regardons la sortie de l'expression logique sans les crochets, vous pouvez voir que R renvoie un vecteur contenant soit `TRUE` soit `FALSE` qui indique si la condition logique est remplie pour chaque élément.
Dans ce cas, seuls les éléments en 4^e^ et 8^e^ position renvoient un `TRUE` car leur valeur est supérieure à 4.

```{r}
#| echo: true
#| eval: true
mon_vec > 4
```

Ainsi, ce que R fait en réalité sous le capot est équivalent à :

```{r}
#| echo: true
#| eval: true
mon_vec[c(FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE)]
```

et seuls les éléments qui sont `TRUE` seront extraits.

En plus de `<` et `>` vous pouvez également utiliser des opérateurs composites pour augmenter la complexité de vos expressions.
Par exemple, l'expression "supérieur ou égal à" est : `>=`.
Pour vérifier si une valeur est égale à une autre, nous devons utiliser un double symbole égal `==` et pour vérifier si une valeur est différente de, nous utilisons le symbole `!=` (le symbole `!` signifie "pas").

```{r}
#| echo: true
#| eval: true
mon_vec[mon_vec >= 4] # valeurs supérieures ou égales à 4
mon_vec[mon_vec < 4] # valeurs inférieures à 4
mon_vec[mon_vec <= 4] # valeurs inférieures ou égales à 4
mon_vec[mon_vec == 4] # valeurs égales à 4
mon_vec[mon_vec != 4] # valeurs pas égales à 4
```

Nous pouvons également combiner plusieurs expressions logiques à l'aide d'[expressions booléennes][boolean].
Dans R, l'élément `&` signifie ET et le symbole `|` signifie OU.
Par exemple, pour extraire des valeurs dans `mon_vec` qui sont inférieures à 6 ET supérieures à 2 :

```{r}
#| echo: true
#| eval: true
val26 <- mon_vec[mon_vec < 6 & mon_vec > 2]
val26
```

ou extraire des valeurs dans `mon_vec` qui sont supérieures à 6 OU inférieures à 3 :

```{r}
#| echo: true
#| eval: true
val63 <- mon_vec[mon_vec > 6 | mon_vec < 3]
val63
```

### Remplacement d'éléments

Nous pouvons modifier les valeurs de certains éléments d'un vecteur à l'aide des crochets `[ ]` en combinaison avec l'opérateur d'affectation `<-`.
Par exemple, pour remplacer la 4^e^ valeur de `mon_vec` de `6` à `500` :

```{r}
#| echo: true
#| eval: true
mon_vec[4] <- 500
mon_vec
```

Nous pouvons également remplacer plusieurs valeurs ou même remplacer des valeurs sur la base d'une expression logique :

```{r}
#| echo: true
#| eval: true
# remplacer les 6e et 7e éléments par 100
mon_vec[c(6, 7)] <- 100
mon_vec

# remplacer les éléments inférieurs ou égaux à 4 par 1000
mon_vec[mon_vec <= 4] <- 1000
mon_vec
```

### Ordonner les éléments {#sec-vec-ord}

Outre l'extraction d'éléments particuliers d'un vecteur, il est également possible d'ordonner les valeurs contenues dans un vecteur.
Pour trier les valeurs de la plus petite à la plus grande, nous pouvons utiliser la fonction `sort()` :

```{r}
#| echo: true
#| eval: true
vec_trié <- sort(mon_vec)
vec_trié
```

Pour inverser le tri, du plus élevé au plus bas, nous pouvons soit inclure l'option `decreasing = TRUE` lors de l'utilisation de la fonction `sort()` :

```{r}
#| echo: true
#| eval: true
vec_trié2 <- sort(mon_vec, decreasing = TRUE)
vec_trié2
```

soit trier d'abord le vecteur à l'aide de la fonction `sort()` puis l'inverser à l'aide de la fonction `rev()`.
Il s'agit là d'un autre exemple d'imbrication d'une fonction dans une autre fonction :

```{r}
#| echo: true
#| eval: true
vec_trié3 <- rev(sort(mon_vec))
vec_trié3
```

Bien qu'il soit amusant de trier un seul vecteur, il serait peut-être plus utile de trier un vecteur en fonction des valeurs d'un autre vecteur.
Pour ce faire, nous devons utiliser la fonction `order()` en combinaison avec `[ ]`.
Pour le démontrer, créons un vecteur appelé `taille` contenant la taille de 5 personnes différentes et un autre vecteur appelé `p.noms` contenant les noms de ces personnes (Joanna mesure 180 cm, Charlotte mesure 155 cm, etc.)

```{r}
#| echo: true
#| eval: true
taille <- c(180, 155, 160, 167, 181)
taille

p.noms <- c("Joanna", "Charlotte", "Helen", "Karen", "Amy")
p.noms
```

Notre objectif est de classer les personnes dans `p.noms` dans l'ordre croissant de leur `taille`.
La première chose que nous allons faire est d'utiliser la fonction `order()` avec le vecteur `taille` pour créer un vecteur appelé `taille_ord`

```{r}
#| echo: true
#| eval: true
taille_ord <- order(taille)
taille_ord
```

OK, que se passe-t-il ici ?
La première valeur, `2`(n'oubliez pas d'ignorer `[1]`) doit être lue comme "la plus petite valeur de `taille` est le deuxième élément du vecteur `taille`".
Si nous le vérifions en regardant le vecteur `taille` ci-dessus, nous pouvons voir que le 2^e^ élément a une valeur de 155, ce qui est la plus petite valeur.
La deuxième valeur la plus petite du vecteur `taille` est la 3^e^ ce qui, après vérification, donne 160 et ainsi de suite.
La plus grande valeur de `taille` est la `5`^e^ qui vaut 181.
Maintenant que nous avons le vecteur des indices de position des tailles par ordre croissant (`taille_ord`), nous pouvons extraire ces valeurs de notre vecteur `p.noms` dans cet ordre

```{r}
#| echo: true
#| eval: true
noms_ord <- p.noms[taille_ord]
noms_ord
```

Vous vous demandez probablement à quoi cela peut bien servir.
Imaginons que vous disposiez d'un jeu de données contenant deux colonnes et que vous souhaitiez trier chacune d'entre elles.
Si vous utilisez simplement `sort()` pour trier chaque colonne séparément, les valeurs de chaque colonne seront dissociées les unes des autres.
En utilisant `order()` sur une colonne, un vecteur d'indices de position est créé à partir des valeurs de la colonne dans l'ordre croissant.
Ce vecteur peut être utilisé sur la deuxième colonne, en tant qu'indice d'éléments qui renverront un vecteur de valeurs basé sur la première colonne.
En toute honnêteté, lorsque vous avez plusieurs vecteurs liés, vous devez utiliser un objet de type `data.frame` (voir @sec-data-r) au lieu de plusieurs vecteurs indépendants.

### Vectorisation

L'un des avantages des fonctions R est que la plupart d'entre elles sont vectorisées.
Cela signifie que la fonction opère sur tous les éléments d'un vecteur sans qu'il soit nécessaire d'appliquer la fonction à chaque élément séparément.
Par exemple, pour multiplier chaque élément d'un vecteur par 5, il suffit d'utiliser la fonction :

```{r}
#| echo: true
#| eval: true
# créer un vecteur
mon_vec2 <- c(3, 5, 7, 1, 9, 20)

# multiplier chaque élément par 5
mon_vec2 * 5
```

Ou nous pouvons additionner les éléments de deux vecteurs ou plus :

```{r}
#| echo: true
#| eval: true
# créer un deuxième vecteur
mon_vec3 <- c(17, 15, 13, 19, 11, 0)

# additionner les 2 vecteurs
mon_vec2 + mon_vec3

# multiplier les 2 vecteurs
mon_vec2 * mon_vec3
```

Cependant, vous devez faire attention lorsque vous utilisez la vectorisation avec des vecteurs de longueurs différentes, car R recyclera tranquillement les éléments du vecteur le plus court plutôt que de signaler une erreur.

```{r}
#| echo: true
#| eval: true
# créer un troisième vecteur
mon_vec4 <- c(1, 2)

# additionner les 2 vecteurs - recyclage tranquille!
mon_vec2 + mon_vec4
```

### Données manquantes {#sec-na-vals}

Dans R, les données manquantes sont généralement représentées par un `NA` qui signifie "Not Available" (Non disponible).
Les données peuvent être manquantes pour toute une série de raisons : votre machine est peut-être tombée en panne, vous êtes peut-être tombé en panne, le temps était peut-être trop mauvais pour collecter des données un jour donné, etc.
Les données manquantes peuvent être une véritable plaie, tant du point de vue de R que du point de vue statistique.
Du point de vue de R, les données manquantes peuvent être problématiques car différentes fonctions traitent les données manquantes de différentes manières.
Par exemple, supposons que nous ayons recueilli des relevés de température de l'air pendant 10 jours, mais que notre thermomètre se soit cassé le deuxième et le neuvième jour, de sorte que nous n'avons pas de données pour ces jours-là :

```{r}
#| echo: true
#| eval: true
temp <- c(7.2, NA, 7.1, 6.9, 6.5, 5.8, 5.8, 5.5, NA, 5.5)
temp
```

Nous voulons maintenant calculer la température moyenne sur ces jours à l'aide de la fonction `mean()` :

```{r}
#| echo: true
#| eval: true
temp_moyenne <- mean(temp)
temp_moyenne
```

Si un vecteur a une valeur manquante, la seule valeur possible à renvoyer lors du calcul d'une moyenne est `NA`.
R ne sait pas que vous souhaitez peut-être ignorer la valeur `NA` (R ne peut pas lire dans vos pensées - pour l'instant !).
Si nous regardons le fichier d'aide (en utilisant `?mean` - voir la section suivante @sec-help pour plus de détails) associé à la fonction `mean()` nous pouvons voir qu'il y a un argument `na.rm =` qui prend la valeur `FALSE` par défaut.

> na.rm - une valeur logique indiquant si les valeurs NA doivent être supprimées avant le calcul ("na remove").

Si nous remplaçons cet argument par `na.rm = TRUE` lorsque nous utilisons la fonction `mean()` cela nous permettra d'ignorer les `NA` lors du calcul de la moyenne :

```{r}
#| echo: true
#| eval: true
temp_moyenne <- mean(temp, na.rm = TRUE)
temp_moyenne
```

Il est important de noter que les `NA` n'ont pas été retirés du vecteur `temp` (ce serait une mauvaise pratique), mais que l'objet `mean()` les a simplement ignorées.
Le but de ce qui précède est de souligner comment nous pouvons modifier le comportement par défaut d'une fonction à l'aide d'un argument approprié.
Le problème est que toutes les fonctions n'ont pas d'argument `na.rm =` elles peuvent gérer les `NA` différemment.
Cependant, la bonne nouvelle est que chaque fichier d'aide associé à une fonction vous indiquera **toujours** comment les données manquantes sont traitées par défaut.

## Obtenir de l'aide {#sec-help}

Ce livre est conçu comme une introduction relativement brève à R et, en tant que tel, vous utiliserez bientôt des fonctions et des paquets qui dépassent le cadre de ce texte d'introduction.
Heureusement, l'une des forces de R est son système d'aide complet et facilement accessible, ainsi que la richesse des ressources en ligne où vous pouvez obtenir de plus amples informations.

### Aide R

Pour accéder à l'aide intégrée de R et obtenir des informations sur n'importe quelle fonction, il suffit d'utiliser la fonction `help()`.
Par exemple, pour ouvrir la page d'aide de notre amie, la fonction `mean()` :

``` r
help("mean")
```

ou vous pouvez utiliser le raccourci `?` devant la fonction :

``` r
?mean
```

la page d'aide est affichée dans l'onglet "Aide"(généralement en bas à droite sur RStudio)

```{r}
#| label: fig-rstudio_help
#| fig-cap: Page d'aide pour la fonction `mean()` dans le panneau Aide sur Rstudio
#| echo: false
#| out-width: 50%
#| fig-align: center
knitr::include_graphics(path = "images/basic/rs_help-fr.png")
```

Il est vrai que les fichiers d'aide peuvent sembler tout sauf utiles lorsque vous commencez à utiliser R.
Cela est probablement dû au fait qu'ils sont écrits de manière très concise et que le langage utilisé est souvent assez technique et plein de jargon.
Cela dit, on s'y habitue et, avec le temps, on finit même par apprécier une certaine beauté dans cette brièveté (honnêtement !).
L'un des aspects les plus intéressants des fichiers d'aide est qu'ils ont tous une structure très similaire, quelle que soit la fonction.
Il est donc facile de naviguer dans le fichier pour trouver exactement ce dont vous avez besoin.

La première ligne du document d'aide contient des informations telles que le nom de la fonction et le paquet d'où elle provient (entre les accolades `{}`, ici `{base}` signifie que la fonction `mean()` fait partie des fonctions de base de R).
D'autres rubriques fournissent des informations plus spécifiques, telles que

+-------------------+----------------------------------------------------------------------------------------------------+
| Rubriques         | Description de la rubrique                                                                         |
+:==================+:===================================================================================================+
| **Description :** | donne une brève description de la fonction et de ce qu'elle fait.                                  |
+-------------------+----------------------------------------------------------------------------------------------------+
| **Usage :**       | donne le nom des arguments associés à la fonction et les éventuelles valeurs par défaut.           |
+-------------------+----------------------------------------------------------------------------------------------------+
| **Arguments :**   | fournit plus de détails sur chaque argument et sur ce qu'il fait.                                  |
+-------------------+----------------------------------------------------------------------------------------------------+
| **Details :**     | donne des détails supplémentaires sur la fonction si nécessaire.                                   |
+-------------------+----------------------------------------------------------------------------------------------------+
| **Value :**       | le cas échéant, indique le type et la structure de l'objet renvoyé par la fonction ou l'opérateur. |
+-------------------+----------------------------------------------------------------------------------------------------+
| **See also :**    | fournit des informations sur d'autres pages d'aide au contenu similaire ou connexe.                |
+-------------------+----------------------------------------------------------------------------------------------------+
| **Examples :**    | donne quelques exemples d'utilisation de la fonction.                                              |
+-------------------+----------------------------------------------------------------------------------------------------+

<!--
: Structure du fichier d'aide {#tbl-help}
-->

Les **Examples** (Exemples d'application) sont très utiles, il suffit de les copier et de les coller dans la console pour voir ce qui se passe.
Vous pouvez également accéder aux exemples à tout moment en utilisant la fonction `example()` (c'est-à-dire `example("mean")`)

La fonction `help()` est utile si vous connaissez le nom de la fonction.
Si vous n'êtes pas sûr du nom, mais que vous vous souvenez d'un mot clé, vous pouvez faire une recherche dans le système d'aide de R à l'aide de la fonction `help.search()`.

``` r
help.search("mean")
```

ou vous pouvez utiliser le raccourci équivalent `??` :

``` r
??mean
```

Les résultats de la recherche seront affichés dans RStudio sous l'onglet "Aide" comme précédemment.
`help.search()` recherche dans la documentation d'aide, les démonstrations de code et les vignettes de paquet et affiche les résultats sous forme de liens cliquables pour une exploration plus approfondie.

```{r}
#| label: fig-rstudio_help2
#| fig-cap: Sortie de la fonction `help.search()` dans Rstudio
#| echo: false
#| out-width: 50%
#| fig-align: center
knitr::include_graphics(path = "images/basic/rs_help2-fr.png")
```

Une autre fonction utile est `apropos()`.
Cette fonction peut être utilisée pour dresser la liste de toutes les fonctions contenant une chaîne de caractères spécifiée.
Par exemple, pour trouver toutes les fonctions avec `mean` dans leur nom :

```{r}
#| echo: true
#| eval: true
apropos("mean")
```

Vous pouvez alors afficher le fichier d'aide de la fonction concernée.

``` r
help("kmeans")
```

Une autre fonction est `RSiteSearch()` qui vous permet de rechercher des mots-clés et des phrases dans les pages d'aide des fonctions et les vignettes de tous les paquets CRAN.
Cette fonction vous permet d'accéder au moteur de recherche du site web de R <https://www.r-project.org/search.html> directement à partir de la console et d'afficher les résultats dans votre navigateur web.

``` r
RSiteSearch("regression")
```

### Autres sources d'aide {#sec-rhelp}

Il n'y a jamais eu de meilleur moment pour commencer à apprendre R.
Il existe pléthore de ressources en ligne disponibles gratuitement, allant de cours complets à des tutoriels et des listes de diffusion spécifiques à un sujet.
Il existe également de nombreuses options payantes si c'est votre truc, mais à moins que vous n'ayez de l'argent à brûler, il n'est vraiment pas nécessaire de dépenser votre argent durement gagné.
Vous trouverez ci-dessous quelques ressources que nous avons trouvées utiles.

#### Ressources générales sur les R

-   [Projet R][r-docs]: Documentation fournie par l'utilisateur
-   [Le journal R][r-journal]: Journal du projet R pour le calcul statistique
-   [Tourbillon][swirl]: Un paquet R qui vous enseigne R de l'intérieur
-   [Les antisèches imprimables de RStudio][rstudio-cheat]
-   [Rseek][rseek] Une recherche Google personnalisée pour les sites liés à R

#### Obtenir de l'aide

-   Cherchez sur internet: utiliser votre moteur de recherche préféré pour chercher les messages d'erreur que vous obtenez.
    Ce n'est pas de la triche et tout le monde le fait !
    Vous serez surpris du nombre de personnes qui ont probablement rencontré le même problème et l'ont résolu.
-   [Stack Overflow][stackr]: Il y a plusieurs milliers de questions relatives à R sur Stack Overflow.
    [Ici][stack-pop] sont les plus populaires, classées par vote.
    Veillez à rechercher des questions similaires avant de poser la vôtre et à inclure un [exemple reproductible][stack-repro] afin d'obtenir les conseils les plus utiles.
    Un exemple reproductible est un exemple minimal qui permet aux personnes qui essaient de vous aider de voir l'erreur elles-mêmes.

#### Ressources R markdown

-   [Référence de base pour markdown et markdown R][bio-con]
-   [Une bonne référence en markdown][md-ref]
-   [Un bon tutoriel de 10 minutes sur le markdown][md-tut]
-   [Feuille de contrôle de RStudio sur le format R markdown][rmd-cheat]
-   [Feuille de référence pour R markdown][rmd-ref]
-   [La documentation R markdown][rs-rm-docs] incluant un [guide de démarrage][rm-lesson] , a [galerie de démonstrations][rm-gallery] et plusieurs [articles][rs-articles] pour une utilisation plus avancée.
-   [Le site web de knitr][knitr] contient de nombreux documents de référence utiles sur le fonctionnement de knitr.

#### Ressources Git et GitHub

-   [Happy Git][git_happy]: Excellente ressource pour l'utilisation de Git et GitHub
-   [Contrôle de version avec RStudio][rs-Git]: Document RStudio pour l'utilisation du contrôle de version
-   [Utiliser Git depuis RStudio][git-rs]: Un bon guide en 10 minutes
-   [La classe R][rclass]: Guide approfondi de l'utilisation de Git et GitHub avec RStudio

#### Programmation R

-   [Programmation R pour la science des données][r-rprog]: Guide approfondi de la programmation R
-   [R pour la science des données][r4ds]: Livre fantastique, orienté tidyverse

## Sauvegarder des données dans R

Votre approche de l'enregistrement du travail dans R et RStudio dépend de ce que vous voulez enregistrer.
La plupart du temps, la seule chose que vous devrez sauvegarder est le code R de vos scripts.
N'oubliez pas que votre script est un enregistrement reproductible de tout ce que vous avez fait.
Il vous suffit donc d'ouvrir votre script dans une nouvelle session RStudio et de l'exécuter dans la console R pour revenir à l'endroit où vous vous étiez arrêté.

À moins que vous n'ayez suivi notre suggestion de modifier les paramètres par défaut des projets RStudio (voir @sec-rsprojs), il vous sera demandé si vous souhaitez sauvegarder l'image de votre espace de travail à chaque fois que vous quitterez RStudio.
Nous pensons que dans 99,9 % des cas, vous ne souhaitez pas le faire.
En commençant avec une session RStudio propre chaque fois que nous revenons à notre analyse, nous pouvons être sûrs d'éviter tout conflit potentiel avec les choses que nous avons faites dans les sessions précédentes.

Cependant, il est parfois utile de sauvegarder les objets que vous avez créés dans R.
Par exemple, imaginons que vous créiez un objet dont la génération nécessite des heures (voire des jours) de temps de calcul.
Il serait extrêmement gênant de devoir attendre tout ce temps à chaque fois que vous revenez sur votre analyse. Cependant, dans ce cas, nous pouvons enregistrer cet objet en tant que fichier externe, `.RData` que nous pourrons charger dans RStudio la prochaine fois que nous voudrons l'utiliser.
Pour enregistrer un objet dans un fichier `.RData` vous pouvez utiliser la fonction `save()` (remarquez que nous n'avons pas besoin d'utiliser l'opérateur d'affectation ici) :

``` r
save(nomDelObjet, file = "nom_du_fichier.RData")
```

ou si vous souhaitez sauvegarder tous les objets de votre espace de travail dans un seul fichier `.RData` utilisez la fonction `save.image()` :

``` r
save.image(file = "nom_du_fichier.RData")
```

Pour charger votre `.RData` dans RStudio, utilisez la fonction `load()` :

``` r
load(file = "nom_du_fichier.RData")
```

## Paquets R {#sec-packages}

L'installation de base de R est livrée avec de nombreux paquets utiles.
Ces paquets contiennent de nombreuses fonctions que vous utiliserez quotidiennement.
Cependant, lorsque vous commencerez à utiliser R pour des projets plus variés (et que votre propre utilisation de R évoluera), vous constaterez qu'il y a un moment où vous aurez besoin d'étendre les capacités de R.
Heureusement, des milliers d'utilisateurs de R ont développé du code utile et l'ont partagé sous forme de paquets installables.
Vous pouvez considérer un paquet comme une collection de fonctions, de données et de fichiers d'aide rassemblés dans une structure standard bien définie que vous pouvez télécharger et installer dans R.
Ces paquets peuvent être téléchargés à partir de diverses sources, mais les plus populaires sont les suivantes [CRAN][cran-packages], [Bioconductor][bioconductor] et [GitHub][github] .
Actuellement, le CRAN héberge plus de 15 000 paquets et est le dépôt officiel des paquets R fournis par les utilisateurs.
Bioconductor fournit des logiciels libres orientés vers la bioinformatique et héberge plus de 1800 paquets R.
GitHub est un site web qui héberge des dépôts git pour toutes sortes de logiciels et de projets (pas seulement R).
Souvent, les versions de développement de pointe des paquets R sont hébergées sur GitHub, donc si vous avez besoin de toutes les nouvelles fonctionnalités, cela peut être une option.
Cependant, l'inconvénient potentiel de l'utilisation de la version de développement d'un paquet R est qu'elle peut ne pas être aussi stable que la version hébergée sur CRAN (elle est en cours de développement !) et que la mise à jour des paquets ne sera pas automatique.

### Utilisation des paquets

Une fois que vous avez installé un paquet sur votre ordinateur, vous ne pouvez pas l'utiliser immédiatement.
Pour utiliser un paquet, vous devez d'abord le charger à l'aide de la fonction `library()`. Par exemple, pour charger le paquet `remotes` :package: que vous avez installé précédemment :

``` r
library(remotes)
```

La fonction `library()` chargera également tous les paquets supplémentaires nécessaires et pourra afficher des informations supplémentaires sur les paquets dans la console.
Il est important de savoir que chaque fois que vous démarrez une nouvelle session R (ou que vous restaurez une session précédemment sauvegardée), vous devez charger les paquets que vous utiliserez.
Nous avons tendance à mettre tous nos `library()` nécessaires à notre analyse en tête de nos scripts R afin de les rendre facilement accessibles et de pouvoir les compléter au fur et à mesure du développement de notre code.
Si vous essayez d'utiliser une fonction sans avoir préalablement chargé le paquet R correspondant, vous recevrez un message d'erreur indiquant que R n'a pas pu trouver la fonction.
Par exemple, si vous essayez d'utiliser la fonction `install_github()` sans charger le paquet `remotes` :package: en premier lieu, vous obtiendrez l'erreur suivante :

``` r
install_github("tidyverse/dplyr")

# Error in install_github("tidyverse/dplyr") :
#  could not find function "install_github"
```

Il peut parfois être utile d'utiliser une fonction sans utiliser au préalable la fonction`library()`.
Si, par exemple, vous n'utilisez qu'une ou deux fonctions dans votre script et que vous ne souhaitez pas charger toutes les autres fonctions d'un paquet, vous pouvez accéder directement à la fonction en spécifiant le nom du paquet, suivi de deux points (2 fois) `::`, puis du nom de la fonction :

``` r
remotes::install_github("tidyverse/dplyr")
```

C'est ainsi que nous avons pu utiliser la fonction `install()` et `install_github()` [ci-dessous][Paquets Bioconductor] sans charger les paquets au préalable`BiocManager` :package: et `remotes` :package: .
La plupart du temps, nous recommandons d'utiliser la fonction `library()`.

### Installation des paquets R

#### Paquets CRAN {#sec-cran-packages}

Pour installer un paquet à partir du CRAN, vous pouvez utiliser la fonction `install.packages()`.
Par exemple, si vous voulez installer le paquet `remotes` :package: entrez le code suivant dans la Console (note : vous aurez besoin d'une connexion internet fonctionnelle pour effectuer cette opération) :

``` r
install.packages("remotes", dependencies = TRUE)
```

Il vous sera peut-être demandé de choisir un miroir CRAN, sélectionnez simplement '0-cloud' ou un miroir proche de votre localisation.
L'argument `dependencies = TRUE` permet de s'assurer que les paquets supplémentaires nécessaires seront également installés.

Il est conseillé de mettre régulièrement à jour les paquets déjà installés afin de bénéficier des nouvelles fonctionnalités et des corrections de bogues.
Pour mettre à jour les paquets CRAN, vous pouvez utiliser la commande `update.packages()` (vous aurez besoin d'une connexion internet pour cela) :

``` r
update.packages(ask = FALSE)
```

L'argument `ask = FALSE` évite d'avoir à confirmer chaque téléchargement de paquet, ce qui peut être fastidieux si de nombreux paquets sont installés.

#### Paquets Bioconductor

Pour installer des paquets de Bioconductor, le processus est [un peu différent][bioc-install].
Vous devez d'abord installer le paquet `BiocManager` :package:.
Vous ne devez le faire qu'une seule fois, sauf si vous réinstallez ou mettez à jour R.

``` r
install.packages("BiocManager", dependencies = TRUE)
```

Une fois que `BiocManager` a été installé, vous pouvez soit installer tous les paquets "de base" de Bioconductor avec la commande :

``` r
BiocManager::install()
```

ou installer des paquets spécifiques tels que le `GenomicRanges` :package: et `edgeR` :package: :

``` r
BiocManager::install(c("GenomicRanges", "edgeR"))
```

Pour mettre à jour les paquets de Bioconductor, il suffit d'utiliser la commande `BiocManager::install()` à nouveau :

``` r
BiocManager::install(ask = FALSE)
```

Là encore, vous pouvez utiliser l'argument `ask = FALSE` pour éviter d'avoir à confirmer chaque téléchargement de paquet.

#### Paquets GitHub

Il existe plusieurs options pour installer les paquets hébergés sur GitHub.
La méthode la plus efficace est sans doute d'utiliser la fonction `install_github()` du paquet `remotes` :package: (vous avez installé ce paquet précédemment, @sec-cran-packages).
Avant d'utiliser la fonction, vous devez connaître le nom d'utilisateur GitHub du propriétaire du répertoire ainsi que le nom du répertoire.
Par exemple, la version de développement de `dplyr` :package: de Hadley Wickham est hébergée sur le compte GitHub de tidyverse et porte le nom de répertoire "dplyr" (recherchez simplement "github dplyr").
Pour installer cette version depuis GitHub, utilisez :

``` r
remotes::install_github("tidyverse/dplyr")
```

Le moyen le plus sûr (à notre connaissance) de mettre à jour un paquet installé depuis GitHub est de le réinstaller en utilisant la commande ci-dessus.

```{r}
#| label: links
#| child: images/_links.md
```
